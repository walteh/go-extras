# Go Debug Extension Integration: Seamless Cross-Boundary Debugging

## Overview

Integrate cross-boundary debugging capabilities into the existing `go-extras` VS Code extension that **seamlessly works with the official Go extension's test manager UI**. When debugging Go tests that interact with containerd shims, the extension will automatically launch the containerd shim under a headless Delve server and spawn a nested remote-attach debug session, providing unified debugging across test binary and shim code boundaries.

**Critical Requirement**: The implementation must work transparently with VS Code's native Go test debugging workflow - users should be able to click "Debug Test" in the test manager UI and have cross-boundary debugging work automatically.

## Problem Statement

Currently, debugging Go tests that interact with containerd shims requires:

-   Manual setup of multiple debug sessions
-   Complex configuration management
-   Separate debugging contexts for test code and shim code
-   No unified view of the call stack across boundaries
-   **Incompatibility with VS Code's test manager UI** - users can't simply click "Debug Test"

## Proposed Solution

Extend the existing `go-extras` VS Code extension to:

1. **Transparently intercept** VS Code Go extension's test debug requests
2. Launch containerd shim under a headless `dlv --accept-multiclient` server
3. Automatically spawn a nested "remote-attach" debug session
4. Display both stacks (test binary + shim) in unified tree view
5. **Work seamlessly** with VS Code's test manager UI and existing Go extension workflow
6. Integrate with existing CodeLens functionality without disruption

## Seamless Integration Requirements

### Test Manager UI Compatibility

The implementation **must** work with:

-   VS Code's built-in test manager UI (`Test` panel)
-   "Debug Test" buttons that appear next to individual tests
-   Test discovery and execution from the Go extension
-   Standard Go debug configurations (`launch.json`)

### No User Workflow Changes

Users should experience:

-   **Same debugging experience** as normal Go tests
-   **Automatic detection** when tests interact with containerd shims
-   **Zero configuration** for basic use cases
-   **Transparent operation** - they don't need to know cross-boundary debugging is happening

## Technical Architecture

### Current Project Structure

```
go-extras/
â”œâ”€â”€ tools/go.mod                    # Go tools via 'go tool <name>'
â”œâ”€â”€ editors/vscode/                 # VS Code extension
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ extension.ts            # Main extension activation
â”‚   â”‚   â”œâ”€â”€ codelens.ts            # Existing CodeLens functionality
â”‚   â”‚   â”œâ”€â”€ wasm.ts                # Generic WASM wrapper
â”‚   â”‚   â””â”€â”€ wasm-examples.ts       # WASM usage examples
â”‚   â”œâ”€â”€ package.json               # Extension manifest & dependencies
â”‚   â””â”€â”€ bun.lockb                  # Locked dependencies
â””â”€â”€ docs/
    â”œâ”€â”€ issue-00001.md             # This document
    â””â”€â”€ issue-00002.md             # CodeLens enhancements
```

### Enhanced Extension Structure

```
editors/vscode/src/
â”œâ”€â”€ extension.ts                    # Main extension - register debug provider
â”œâ”€â”€ codelens.ts                    # Existing CodeLens functionality
â”œâ”€â”€ debug/                         # New debug functionality
â”‚   â”œâ”€â”€ provider.ts                # DebugConfigurationProvider (intercepts Go extension)
â”‚   â”œâ”€â”€ shimDetector.ts            # Detects when tests need shim debugging
â”‚   â”œâ”€â”€ shimLauncher.ts            # Delve server management
â”‚   â”œâ”€â”€ sessionManager.ts          # Manages nested debug sessions
â”‚   â””â”€â”€ types.ts                   # Debug-related type definitions
â”œâ”€â”€ wasm.ts                        # Generic WASM wrapper
â””â”€â”€ wasm-examples.ts               # WASM usage examples
```

### Critical Integration Points

| Component                     | Purpose                                         | Implementation Strategy                                        |
| ----------------------------- | ----------------------------------------------- | -------------------------------------------------------------- |
| **Test Manager Interception** | Capture debug requests from VS Code test UI     | Register `DebugConfigurationProvider` for "go" type            |
| **Shim Detection**            | Identify when tests interact with containerd    | Analyze test code/imports for shim dependencies                |
| **Configuration Enhancement** | Modify debug config before Go extension sees it | Inject additional debug session in `resolveDebugConfiguration` |
| **Session Hierarchy**         | Nested sessions in CALL STACK view              | Use `parentSession` parameter (VS Code v1.33+)                 |
| **Delve Multi-Client**        | Allow multiple debugger connections             | `--accept-multiclient` and `--continue` flags                  |
| **CodeLens Integration**      | Show debug context in existing CodeLens         | Enhance reference counts with debug information                |

## Implementation Specification

### 1. Seamless Debug Provider Registration

```typescript
// extension.ts - Register as Go debug provider
export function activate(context: vscode.ExtensionContext) {
	// Existing CodeLens functionality
	const codeLensProvider = new GoExtrasCodeLensProvider();

	// Critical: Register debug provider for "go" type to intercept Go extension requests
	const debugProvider = new GoExtrasDebugProvider();

	context.subscriptions.push(
		vscode.languages.registerCodeLensProvider({ scheme: "file", language: "go" }, codeLensProvider),
		// This intercepts ALL Go debug requests, including from test manager UI
		vscode.debug.registerDebugConfigurationProvider("go", debugProvider)
	);
}
```

### 2. Transparent Debug Configuration Provider

```typescript
// debug/provider.ts - Intercept and enhance Go debug configurations
export class GoExtrasDebugProvider implements vscode.DebugConfigurationProvider {
	async resolveDebugConfiguration(
		folder: vscode.WorkspaceFolder | undefined,
		config: vscode.DebugConfiguration,
		token?: vscode.CancellationToken
	): Promise<vscode.DebugConfiguration> {
		// Only enhance test mode configurations
		if (config.mode !== "test") {
			return config; // Pass through non-test configs unchanged
		}

		// Detect if this test interacts with containerd shims
		const needsShimDebugging = await this.detectShimInteraction(config);

		if (!needsShimDebugging) {
			return config; // Pass through normal test configs unchanged
		}

		// SEAMLESS ENHANCEMENT: Add shim debugging without breaking existing config
		const shimPort = await this.shimLauncher.ensureShimServer();

		// Return enhanced configuration that the Go extension will execute
		return {
			...config,
			// Add nested session for shim debugging
			compounds: [
				{
					name: config.name || "Debug Test",
					configurations: [config.name || "Debug Test", "Attach to Shim"],
				},
			],
			configurations: [
				config, // Original test debug config
				{
					name: "Attach to Shim",
					type: "go",
					request: "attach",
					mode: "remote",
					remotePath: "",
					port: shimPort,
					host: "127.0.0.1",
				},
			],
		};
	}

	private async detectShimInteraction(config: vscode.DebugConfiguration): Promise<boolean> {
		// Analyze test files for containerd/shim imports or patterns
		// This could use WASM for advanced static analysis
		return this.shimDetector.analyzeTestCode(config.program);
	}
}
```

### 3. Test Manager UI Integration

```typescript
// debug/shimDetector.ts - Detect when tests need cross-boundary debugging
export class ShimDetector {
	async analyzeTestCode(testPath: string): Promise<boolean> {
		// Read test files and check for shim interaction patterns
		const testFiles = await this.findTestFiles(testPath);

		for (const file of testFiles) {
			const content = await fs.readFile(file, "utf8");

			// Check for containerd/shim imports
			if (
				content.includes("github.com/containerd/containerd") ||
				content.includes("github.com/containerd/shim") ||
				content.includes("containerd/v2/shim")
			) {
				return true;
			}

			// Check for shim binary execution patterns
			if (content.match(/exec\.Command.*shim/) || content.match(/containerd.*shim/)) {
				return true;
			}
		}

		return false;
	}

	private async findTestFiles(program: string): Promise<string[]> {
		// Find all *_test.go files in the program directory
		// This works with VS Code's test discovery
		return glob.sync(path.join(program, "**/*_test.go"));
	}
}
```

## VS Code Test Manager Integration

### Test Discovery Compatibility

The implementation preserves VS Code's native test discovery:

1. **Go extension** scans for `*_test.go` files
2. **Test manager UI** displays discovered tests with "Debug Test" buttons
3. **User clicks "Debug Test"** - this creates a standard Go debug configuration
4. **Our debug provider** intercepts the configuration via `resolveDebugConfiguration`
5. **Shim detection** analyzes if the test needs cross-boundary debugging
6. **Enhanced configuration** is returned to VS Code for execution
7. **User sees normal debugging** with additional shim context automatically available

### Debug Session User Experience

When debugging tests with shim interaction:

1. **Single click** on "Debug Test" in test manager UI
2. **Automatic detection** that test interacts with containerd shim
3. **Shim process launched** automatically under Delve headless server
4. **Two debug sessions** appear in CALL STACK view:
    - Primary: Test binary (normal debug session)
    - Nested: Containerd shim (remote attach session)
5. **Unified debugging** - step through test code and shim code seamlessly
6. **Standard VS Code debugging** - all normal debugging features work

## Package.json Updates

```json
{
	"name": "go-extras",
	"contributes": {
		"debuggers": [
			{
				"type": "go",
				"configurationSnippets": [
					{
						"label": "Go: Debug Test with Shim Support",
						"description": "Debug Go test with automatic containerd shim debugging",
						"body": {
							"name": "Debug Test + Shim",
							"type": "go",
							"request": "launch",
							"mode": "test",
							"program": "${workspaceFolder}",
							"enableShimDebugging": true
						}
					}
				]
			}
		],
		"commands": [
			{
				"command": "go-extras.showReferences",
				"title": "Show References"
			},
			{
				"command": "go-extras.toggleShimDebugging",
				"title": "Toggle Shim Debugging"
			}
		],
		"configuration": {
			"title": "Go Extras",
			"properties": {
				"go-extras.codeLens.enabled": {
					"type": "boolean",
					"default": true,
					"description": "Enable CodeLens functionality"
				},
				"go-extras.debug.autoDetectShims": {
					"type": "boolean",
					"default": true,
					"description": "Automatically detect and debug containerd shims"
				},
				"go-extras.debug.shimPath": {
					"type": "string",
					"default": "",
					"description": "Path to containerd shim binary for debugging"
				},
				"go-extras.debug.showShimSessions": {
					"type": "boolean",
					"default": true,
					"description": "Show nested shim debug sessions in call stack"
				}
			}
		}
	}
}
```

## Success Criteria

### Seamless Integration Requirements

1. **Zero User Friction**: Users can debug tests with shim interaction using normal VS Code test UI
2. **Backwards Compatibility**: All existing Go debugging workflows continue to work unchanged
3. **Automatic Detection**: Extension automatically detects when cross-boundary debugging is needed
4. **Standard UI**: Uses VS Code's standard debug UI - no custom panels or workflows required
5. **Performance**: <200ms overhead for debug session establishment
6. **Test Manager UI**: Works perfectly with "Debug Test" buttons in test explorer

### Technical Requirements

1. **Go Extension Compatibility**: Works with official Go extension without conflicts
2. **Configuration Transparency**: Enhances debug configurations without breaking them
3. **Session Management**: Properly manages nested debug sessions and cleanup
4. **Error Handling**: Graceful fallback when shim debugging fails
5. **CodeLens Integration**: Existing CodeLens features enhanced with debug context

### User Experience Goals

-   **One-click debugging** for complex test scenarios
-   **Unified call stack view** showing both test and shim execution
-   **Standard debugging controls** work across both sessions
-   **Invisible complexity** - users don't need to understand the implementation
-   **Reliable operation** - consistent behavior across different test scenarios

This implementation will make `go-extras` an essential tool for developers working with containerd and container runtime code, providing a debugging experience that "just works" with VS Code's existing test infrastructure.

### Additional Notes

Below is a readyâ€‘toâ€‘paste markdown comment you can drop into the GitHub issue.
It preserves your original structure but flags the subtle gaps and suggests small tweaks that will make the extension â€œjust workâ€ for anyone who presses Debugâ€¯Test.

â¸»

ðŸ“â€¯Review notes on the proposed shimâ€‘aware debug flow

1â€¯Â Debugâ€‘provider mechanics

Item in spec Reality check & recommended fix
Return a compounds array fromâ€¯resolveDebugConfiguration() VSÂ Code ignores compounds when it comes from a provider; it only evaluates it when the userâ€™s launch.json or the Test UI supplies itÂ  ï¿¼. Fix: start the parent session normally, then in an onDidStartDebugSession listener call vscode.debug.startDebugging(folder, shimCfg, parentSession) to spawn the nested session.
Child config uses request:"attach" The Go debug adapter treats remote attach as request:"launch",Â mode:"remote"Â  ï¿¼. Change accordingly or youâ€™ll hit schema validation errors.
Single provider intercepts all Go configs Register your provider with DebugConfigurationProviderTriggerKind.Initial so the official Go provider still chains its own resolveDebugConfiguration afterwards; this keeps future Goâ€‘extension features workingÂ  ï¿¼.

2â€¯Â Nested session UX

VSÂ Code collapses sessions into a single CALLÂ STACK tree when parentSession is suppliedÂ  ï¿¼.
This is exactly what you wantâ€”users still see one node per test until they expand it.

3â€¯Â Delve server lifetime
â€¢ Use dlv --headless --acceptâ€‘multiclient --continue so a single shim debugger stays alive across many test runsÂ  ï¿¼ ï¿¼ ï¿¼.
â€¢ Spawn it once per workspace and stash the chosen port in process.env.HARPOON_DLV_PORT to amortise startâ€‘up cost (<â€¯100â€¯ms reconnect on macOS in practice).

4â€¯Â Port & process hygiene
â€¢ Allocate a free port with net.createServer().listen(0); this avoids clashes when users run tests concurrently in split terminalsÂ  ï¿¼.
â€¢ On onDidTerminateDebugSession, check for orphaned dlv pids and kill themâ€”VSÂ Code sometimes fires onDidTerminate even if the session never fully startedÂ  ï¿¼.

5â€¯Â Shimâ€‘detection escape hatch

Static import scanning is fine but add a boolean setting such as:

"go-extras.debug.autoDetectShims": true

so users can disable shim logic for edge cases or CI runs without uninstalling the extension.

6â€¯Â Successâ€‘criteria wording
â€¢ Clarify whether the <200â€¯ms overhead target is average or p95; CI can only enforce oneÂ  ï¿¼.
â€¢ Consider renaming shimPath to containerdShim.path to avoid future namespace collisions in your contributes.configuration block.

â¸»

âœ…â€¯Summary

With these small adjustmentsâ€”especially launching the child session programmatically instead of returning a compounds blockâ€”the companion extension will truly be an installâ€‘andâ€‘forget addâ€‘on:
â€¢ Zero user config: Test Explorer & CodeLens keep working outâ€‘ofâ€‘theâ€‘box.
â€¢ Unified call stack: thanks to parentSession, no UI clutter.
â€¢ Single longâ€‘lived dlv: --acceptâ€‘multiclient covers every test run without extra startâ€‘up lag.

Once wired, hitting Debugâ€¯Test will drop developers straight from their unit test into the containerd shim with no further thought required.
